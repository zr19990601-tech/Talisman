<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>太乙金符：星云太极交互系统</title>
    <style>
        :root {
            --gold: #FFD700;
            --blue: #0077FF;
            --white: #FFFFFF;
            --bg: #000000;
        }

        body, html {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'PingFang SC', 'STKaiti', serif;
        }

        #canvas-container {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 1;
        }

        /* 初始遮罩界面 */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #000;
            transition: opacity 1.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #ui-layer.hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 2.8rem;
            letter-spacing: 1.5rem;
            margin-bottom: 2rem;
            background: linear-gradient(135deg, var(--white) 0%, var(--gold) 50%, var(--blue) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 200;
        }

        #start-btn {
            padding: 18px 60px;
            background: transparent;
            color: var(--gold);
            border: 1px solid var(--gold);
            cursor: pointer;
            font-size: 1.1rem;
            letter-spacing: 8px;
            transition: all 0.4s;
            border-radius: 2px;
        }

        #start-btn:hover {
            background: rgba(255, 215, 0, 0.1);
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.3);
        }

        #status-msg {
            margin-top: 2rem;
            color: #444;
            font-size: 0.85rem;
            letter-spacing: 2px;
            height: 1rem;
        }

        /* 交互反馈提示 */
        #hint-ui {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 20px;
            opacity: 0;
            transition: opacity 1s;
            pointer-events: none;
        }

        .hint-item {
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 28px;
            border: 1px solid rgba(0, 119, 255, 0.25);
            font-size: 0.85rem;
            color: var(--blue);
            backdrop-filter: blur(15px);
            border-radius: 4px;
        }

        #webcam-preview {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 112px;
            border-radius: 4px;
            border: 1px solid rgba(0, 119, 255, 0.3);
            transform: scaleX(-1);
            object-fit: cover;
            opacity: 0;
            transition: opacity 1s;
            z-index: 60;
            pointer-events: none;
        }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/+esm"
        }
    }
    </script>
</head>
<body>

    <div id="canvas-container"></div>
    
    <div id="ui-layer">
        <h1>太乙金符</h1>
        <button id="start-btn">凝神起法</button>
        <div id="status-msg">准备就绪</div>
    </div>

    <div id="hint-ui">
        <div class="hint-item">✋ 张手：星云逸散</div>
        <div class="hint-item">✊ 握拳：神咒化现</div>
    </div>

    <video id="webcam-preview" autoplay playsinline muted></video>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- 核心咒语数据 ---
        const MANTRA_RAW = "天地玄宗，万炁本根。广修亿劫，证吾神通。三界内外，惟道独尊。体有金光，覆映吾身。视之不见，听之不闻。包罗天地，养育群生。受持万遍，身有光明。三界侍卫，五帝司迎。万神朝礼，役使雷霆。鬼妖丧胆，精怪忘形。内有霹雳，雷神隐名。洞慧交彻，五炁腾腾。金光速现，覆护真人。急急如律令。";
        const MANTRA_SEGMENTS = MANTRA_RAW.replace(/[，。]/g, '').match(/.{1,4}/g);
        const P_COUNT = 60000;
        
        const state = {
            active: false,
            transition: 1.0, 
            targetTransition: 1.0,
            handPos: new THREE.Vector3(0, 0, 0),
            camLerp: new THREE.Vector2(0, 0),
            
            // 太极动态控制
            taijiAngle: 0,
            currentRotationSpeed: 0,
            phaseLaps: 0, // 当前阶段已转圈数
            isFastCCW: true // true: 快速逆时针, false: 慢速顺时针
        };

        const dom = {
            btn: document.getElementById('start-btn'),
            overlay: document.getElementById('ui-layer'),
            status: document.getElementById('status-msg'),
            video: document.getElementById('webcam-preview'),
            hint: document.getElementById('hint-ui')
        };

        let scene, camera, renderer, composer, bloomPass, handLandmarker, uniforms, taijiMesh, mantraGroup, starField;

        // --- 太极 Shader: 中心对称，锐利无边 ---
        const taijiShader = {
            vertex: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragment: `
                varying vec2 vUv;
                void main() {
                    vec2 p = vUv * 2.0 - 1.0;
                    float r = length(p);
                    if(r > 0.98) discard;

                    // 阴阳逻辑
                    float mask = step(0.0, p.x);
                    float d_top = length(p - vec2(0.0, 0.5));
                    float d_bottom = length(p - vec2(0.0, -0.5));
                    
                    if(d_top < 0.5) mask = 0.0;
                    if(d_bottom < 0.5) mask = 1.0;

                    // 鱼眼
                    if(d_top < 0.11) mask = 1.0;
                    if(d_bottom < 0.11) mask = 0.0;

                    vec3 black = vec3(0.03);
                    vec3 white = vec3(0.96);
                    vec3 col = mix(black, white, mask);

                    float alpha = smoothstep(0.98, 0.95, r);
                    gl_FragColor = vec4(col, 0.65 * alpha); 
                }
            `
        };

        // --- 初始化 MediaPipe 手势识别与摄像头 ---
        async function startritual() {
            dom.btn.disabled = true;
            dom.status.innerText = "正在敕封法阵引擎 (Loading AI)...";
            
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO", numHands: 1
                });

                dom.status.innerText = "法眼开通中 (Requesting Camera)...";
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 640, height: 480, frameRate: 30 } 
                });
                dom.video.srcObject = stream;
                await new Promise(r => dom.video.onloadedmetadata = r);
                dom.video.play();

                setupGraphics();
                dom.overlay.classList.add('hidden');
                dom.video.style.opacity = "0.2";
                dom.hint.style.opacity = "1";
                state.active = true;
                animate();
            } catch (err) {
                dom.status.innerText = "法阵启动失败: " + err.message;
                dom.btn.disabled = false;
            }
        }

        dom.btn.addEventListener('click', startritual);

        function setupGraphics() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 35;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const renderPass = new RenderPass(scene, camera);
            // 调优辉光阈值，减少整体曝光
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.4, 0.9);
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            // 1. 太极图案 (调整尺寸: 8.0缩小1/6 -> 约6.67)
            const taijiGeo = new THREE.PlaneGeometry(6.67, 6.67);
            const taijiMat = new THREE.ShaderMaterial({
                vertexShader: taijiShader.vertex,
                fragmentShader: taijiShader.fragment,
                transparent: true,
                depthWrite: false
            });
            taijiMesh = new THREE.Mesh(taijiGeo, taijiMat);
            taijiMesh.position.z = 12;
            scene.add(taijiMesh);

            // 2. 咒语文本 (随机散落布局)
            createDisorderedMantras();

            // 3. 星云粒子 (抗曝光优化版)
            createNebula();

            window.addEventListener('resize', onResize);
        }

        function createDisorderedMantras() {
            mantraGroup = new THREE.Group();
            MANTRA_SEGMENTS.forEach((txt) => {
                const canvas = document.createElement('canvas');
                canvas.width = 128; canvas.height = 512;
                const ctx = canvas.getContext('2d');
                ctx.font = "bold 44px 'Noto Serif SC', serif";
                ctx.fillStyle = "#0088FF"; ctx.textAlign = "center";
                ctx.shadowColor = "#0044FF"; ctx.shadowBlur = 15;
                for (let j = 0; j < txt.length; j++) { ctx.fillText(txt[j], 64, 85 + j * 100); }

                const tex = new THREE.CanvasTexture(canvas);
                const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0 });
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 10), mat);
                mesh.position.set((Math.random()-0.5)*80, (Math.random()-0.5)*50, -15 - Math.random()*15);
                mesh.userData = { phase: Math.random()*Math.PI*2, floatSpeed: 0.005 + Math.random()*0.015 };
                mantraGroup.add(mesh);
            });
            scene.add(mantraGroup);
        }

        // --- 核心优化：高清晰、低曝光粒子 Shader ---
        const particleShader = {
            vertex: `
                uniform float uTime;
                uniform float uTransition;
                uniform vec3 uHandPos;
                attribute vec3 aRandom;
                attribute vec3 aColor;
                attribute float aSize;
                varying vec3 vColor;
                varying float vAlpha;

                vec3 curl(vec3 p) {
                    float s = uTime * 0.12;
                    return vec3(sin(p.y+s)+sin(p.z+s), sin(p.x+s)+sin(p.z+s), sin(p.x+s)+sin(p.y+s));
                }

                void main() {
                    vec3 pos = aRandom * 34.0 + curl(aRandom * 6.5) * 12.0;
                    float d = distance(pos, uHandPos);
                    if(d < 15.0) {
                        float force = (1.0 - d/15.0) * uTransition * 4.5;
                        pos += normalize(pos - uHandPos) * force;
                    }
                    vec4 mvPos = viewMatrix * vec4(pos, 1.0);
                    // 聚气态时粒子缩小至几乎不可见
                    gl_PointSize = aSize * (380.0 / -mvPos.z) * mix(0.1, 1.0, uTransition);
                    gl_Position = projectionMatrix * mvPos;
                    vColor = aColor;
                    // 降低基础不透明度，防止重叠区域泛白
                    vAlpha = uTransition * 0.7;
                }
            `,
            fragment: `
                varying vec3 vColor;
                varying float vAlpha;
                void main() {
                    float d = distance(gl_PointCoord, vec2(0.5));
                    if(d > 0.5) discard;
                    // 增强幂指数 (3.5->4.5)，让光斑更小、更硬、中心更清晰
                    float strength = pow(1.0 - d * 2.0, 4.5);
                    gl_FragColor = vec4(vColor, strength * vAlpha);
                }
            `
        };

        function createNebula() {
            const geo = new THREE.BufferGeometry();
            const rnd = new Float32Array(P_COUNT * 3), col = new Float32Array(P_COUNT * 3), siz = new Float32Array(P_COUNT);
            for (let i = 0; i < P_COUNT; i++) {
                const i3 = i * 3;
                rnd[i3] = Math.random()-0.5; rnd[i3+1] = Math.random()-0.5; rnd[i3+2] = Math.random()-0.5;
                const r = Math.random();
                if(r > 0.72) { col[i3]=1.0; col[i3+1]=0.85; col[i3+2]=0.2; } // 金色
                else if(r > 0.38) { col[i3]=0.1; col[i3+1]=0.6; col[i3+2]=1.0; } // 蓝色
                else { col[i3]=0.95; col[i3+1]=0.95; col[i3+2]=1.0; } // 白色
                siz[i] = 1.0 + Math.random() * 4.5;
            }
            geo.setAttribute('aRandom', new THREE.BufferAttribute(rnd, 3));
            geo.setAttribute('aColor', new THREE.BufferAttribute(col, 3));
            geo.setAttribute('aSize', new THREE.BufferAttribute(siz, 1));
            geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(P_COUNT * 3), 3));
            uniforms = { uTime: { value: 0 }, uTransition: { value: 1.0 }, uHandPos: { value: new THREE.Vector3(0,0,0) } };
            const mat = new THREE.ShaderMaterial({
                uniforms, vertexShader: particleShader.vertex, fragmentShader: particleShader.fragment,
                transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
            });
            starField = new THREE.Points(geo, mat);
            scene.add(starField);
        }

        function animate() {
            if (!state.active) return;
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            uniforms.uTime.value = time;

            // 1. 手势处理与状态切换
            const results = handLandmarker.detectForVideo(dom.video, performance.now());
            if (results.landmarks && results.landmarks.length > 0) {
                const marks = results.landmarks[0];
                const nx = (1 - marks[8].x) * 2 - 1, ny = -(marks[8].y * 2 - 1);
                state.handPos.lerp(new THREE.Vector3(nx * 20, ny * 15, 0), 0.12);
                uniforms.uHandPos.value.copy(state.handPos);
                const d = Math.sqrt(Math.pow(marks[8].x-marks[0].x, 2) + Math.pow(marks[8].y-marks[0].y, 2));
                state.targetTransition = (d < 0.28) ? 0.0 : 1.0;
                state.camLerp.x += (nx * 0.22 - state.camLerp.x) * 0.05; state.camLerp.y += (ny * 0.18 - state.camLerp.y) * 0.05;
                camera.position.x = state.camLerp.x * 6; camera.position.y = state.camLerp.y * 4; camera.lookAt(0, 0, 0);
            }

            state.transition += (state.targetTransition - state.transition) * 0.07;
            uniforms.uTransition.value = state.transition;

            // 2. 太极顿挫动力学：逆快6圈，顺慢6圈
            const lapLimit = 6;
            const fastSpeed = 0.22; // 逆时针速度
            const slowSpeed = -0.04; // 顺时针速度
            
            // 目标角速度
            const targetSpeed = state.isFastCCW ? fastSpeed : slowSpeed;
            state.currentRotationSpeed += (targetSpeed - state.currentRotationSpeed) * 0.045; // 惯性平滑
            
            // 累计当前阶段转动的弧度绝对值
            const deltaAngle = Math.abs(state.currentRotationSpeed);
            state.phaseLaps += deltaAngle / (Math.PI * 2);
            
            // 达到6圈界限，切换状态
            if (state.phaseLaps >= lapLimit) {
                state.isFastCCW = !state.isFastCCW;
                state.phaseLaps = 0;
            }

            state.taijiAngle += state.currentRotationSpeed;
            taijiMesh.rotation.z = state.taijiAngle;

            // 3. 背景咒语隐现
            mantraGroup.children.forEach((mesh) => {
                const data = mesh.userData;
                const wave = Math.sin(time * 1.5 - data.phase) * 0.5 + 0.5;
                mesh.material.opacity = wave * (1.0 - state.transition);
                mesh.position.y += data.floatSpeed; if(mesh.position.y > 30) mesh.position.y = -30;
            });

            composer.render();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>