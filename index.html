<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas Cinematic Miracle - Final Edition</title>
    <style>
        :root {
            --gold: #d4af37;
            --red: #b22222;
            --green: #1b3022;
            --bg: #020406;
        }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Segoe UI', system-ui, sans-serif; color: white; }
        canvas { display: block; }

        /* UI Layer */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: radial-gradient(circle, transparent 20%, #000 120%);
            z-index: 100; transition: opacity 1s;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(30px);
            padding: 40px; border-radius: 28px;
            border: 1px solid rgba(212, 175, 55, 0.3);
            text-align: center; max-width: 500px; box-shadow: 0 30px 60px rgba(0,0,0,0.8);
            pointer-events: auto;
        }

        h1 { color: var(--gold); margin: 0 0 10px 0; text-transform: uppercase; letter-spacing: 4px; font-size: 1.8rem; text-shadow: 0 0 20px rgba(212, 175, 55, 0.5); }
        p { font-size: 0.9rem; color: #ccc; margin-bottom: 30px; line-height: 1.6; }

        .btn-main {
            background: var(--gold); color: #000; border: none; padding: 15px 35px;
            font-weight: bold; border-radius: 40px; cursor: pointer; transition: 0.3s;
            text-transform: uppercase; box-shadow: 0 10px 20px rgba(212, 175, 55, 0.3);
            display: inline-block; width: 240px; font-size: 0.85rem; margin: 8px 0;
        }
        
        .btn-disabled { opacity: 0.3; pointer-events: none; }
        .btn-main:not(.btn-disabled):hover { transform: translateY(-3px); background: #fff; box-shadow: 0 15px 30px rgba(212, 175, 55, 0.5); }

        #upload-btn { background: var(--green); color: white; border: 1px solid var(--gold); }
        #camera-btn { background: var(--red); color: white; border: 1px solid #ff4d4d; }
        #start-btn { background: #fff; color: #000; display: none; }

        #video-feedback {
            position: absolute; bottom: 30px; right: 30px; width: 200px; height: 150px;
            border-radius: 20px; border: 2px solid var(--gold); transform: scaleX(-1);
            background: #000; box-shadow: 0 0 30px rgba(0,0,0,0.5); opacity: 0;
            z-index: 10; object-fit: cover; transition: opacity 0.5s;
        }

        #hint-bar {
            position: absolute; top: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 20px; font-size: 0.85rem; background: rgba(0,0,0,0.8);
            padding: 12px 40px; border-radius: 60px; border: 1px solid rgba(212, 175, 55, 0.2);
            backdrop-filter: blur(15px); z-index: 50;
        }
        .hint-item { display: flex; align-items: center; gap: 8px; color: var(--gold); font-weight: bold; }
        #status-msg { margin-top: 20px; font-size: 0.8rem; color: var(--gold); font-style: italic; opacity: 0.9; }
        
        input[type="file"] { display: none; }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>

    <div id="overlay">
        <div class="glass-panel">
            <h1>ç’€ç’¨è®°å¿†å¥‡å¢ƒ</h1>
            <p>é‡‘è‰²ç›¸æ¡†ä¸éŸ³ç”»åŒæ­¥ç³»ç»Ÿå·²é‡æ„ã€‚<br>è¯·æŒ‰æ­¥éª¤å‡†å¤‡ï¼Œå¼€å¯æ‰‹åŠ¿äº¤äº’ï¼š</p>
            
            <button class="btn-main" id="camera-btn">1. æ¿€æ´»è§†è§‰æ•æ‰</button>
            <input type="file" id="file-input" multiple accept="image/*">
            <input type="file" id="audio-input" accept="audio/*">
            <button class="btn-main btn-disabled" id="upload-btn">2. ä¸Šä¼ è®°å¿†èµ„æº</button>
            <button class="btn-main" id="start-btn">3. å¼€å¯éŸ³ä¹å¹¶è¿›å…¥</button>
            
            <div id="status-msg">ç­‰å¾…è§†è§‰å¼•æ“åˆå§‹åŒ–...</div>
        </div>
    </div>

    <div id="hint-bar" style="display:none;">
        <div class="hint-item">âœŠ èšåˆ</div>
        <div class="hint-item">ğŸ–ï¸ æ•£è½</div>
        <div class="hint-item">ğŸ‘Œ æåˆæ”¾å¤§ç…§ç‰‡</div>
        <div class="hint-item">ğŸ‘‹ æ—‹è½¬è§†è§’</div>
    </div>

    <video id="video-feedback" autoplay playsinline></video>

    <!-- Essential Libs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- å…¨å±€å¸¸é‡ ---
        const COLORS = { gold: 0xD4AF37, red: 0xB22222, green: 0x1B3022, bg: 0x020406 };
        const STATE = { TREE: 'TREE', SCATTER: 'SCATTER', ZOOM: 'ZOOM' };
        let currentState = STATE.TREE;

        let scene, camera, renderer, composer, clock;
        let instancedSpheres, instancedCubes, photoCloud = [], snowPoints, photoFrame;
        let targetRotation = { x: 0, y: 0 };
        let currentRotation = { x: 0, y: 0 };
        let photoData = [];
        const dummy = new THREE.Object3D();

        // éŸ³é¢‘ç³»ç»Ÿï¼šé»˜è®¤è·¯å¾„ + å¤‡é€‰ä¸Šä¼ 
        let audio = new Audio('ezyZip.mp3'); 
        audio.loop = true;

        // --- 1. ä¸‰ç»´åœºæ™¯åŸºç¡€ ---
        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(COLORS.bg, 0.015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 60);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.NoToneMapping;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.body.appendChild(renderer.domElement);

            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.95; // ä¿æŠ¤ç…§ç‰‡åŸè‰²
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const pLight = new THREE.PointLight(0xfff5e1, 3, 150);
            pLight.position.set(20, 40, 30);
            scene.add(pLight);

            clock = new THREE.Clock();
            createTreeGeometry();
            createSnowfall();
            createFrameParticles();
        }

        // --- é‡‘è‰²æµå…‰ç›¸æ¡†ç²’å­ ---
        function createFrameParticles() {
            const count = 350;
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(count * 3);
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({
                color: COLORS.gold,
                size: 0.18,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });
            photoFrame = new THREE.Points(geo, mat);
            photoFrame.visible = false;
            scene.add(photoFrame);
        }

        function updateFrameParticles(width, height) {
            const pos = photoFrame.geometry.attributes.position.array;
            const time = performance.now() * 0.0025;
            const hw = width / 2 + 0.15;
            const hh = height / 2 + 0.15;
            const circumference = (width + height) * 2;

            for (let i = 0; i < 350; i++) {
                let offset = ((i / 350) + time * 0.2) % 1;
                let x, y;
                let s = offset * circumference;

                if (s < width) { x = s - hw; y = hh; }
                else if (s < width + height) { x = hw; y = hh - (s - width); }
                else if (s < width * 2 + height) { x = hw - (s - (width + height)); y = -hh; }
                else { x = -hw; y = -hh + (s - (width * 2 + height)); }

                pos[i * 3] = x + (Math.random() - 0.5) * 0.08;
                pos[i * 3 + 1] = y + (Math.random() - 0.5) * 0.08;
                pos[i * 3 + 2] = 0.08;
            }
            photoFrame.geometry.attributes.position.needsUpdate = true;
        }

        function createTreeGeometry() {
            const count = 400;
            const sGeo = new THREE.SphereGeometry(0.35, 12, 12);
            const sMat = new THREE.MeshStandardMaterial({ color: COLORS.gold, metalness: 0.9, roughness: 0.1, emissive: COLORS.gold, emissiveIntensity: 0.1 });
            instancedSpheres = new THREE.InstancedMesh(sGeo, sMat, count);
            const cGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const cMat = new THREE.MeshStandardMaterial({ color: COLORS.red, roughness: 0.6, metalness: 0.3 });
            instancedCubes = new THREE.InstancedMesh(cGeo, cMat, count);

            const build = (mesh) => {
                for (let i = 0; i < mesh.count; i++) {
                    const y = Math.random() * 32;
                    const r = (32 - y) * 0.35 + 0.6;
                    const theta = Math.random() * Math.PI * 2;
                    const treePos = new THREE.Vector3(Math.cos(theta) * r, y, Math.sin(theta) * r);
                    dummy.position.copy(treePos);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                    if(!mesh.userData.coords) mesh.userData.coords = [];
                    mesh.userData.coords.push({
                        tree: treePos.clone(),
                        scatter: new THREE.Vector3((Math.random()-0.5)*140, Math.random()*85, (Math.random()-0.5)*140)
                    });
                }
            };
            build(instancedSpheres); build(instancedCubes);
            scene.add(instancedSpheres, instancedCubes);
            
            const star = new THREE.Mesh(new THREE.OctahedronGeometry(1.6, 0), new THREE.MeshBasicMaterial({ color: 0xfff0b5 }));
            star.position.y = 32.5;
            scene.add(star);
        }

        function createSnowfall() {
            const snowCount = 2000;
            const snowGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(snowCount * 3);
            const vels = [];
            for (let i = 0; i < snowCount; i++) {
                positions[i*3] = (Math.random()-0.5)*160;
                positions[i*3+1] = Math.random()*100;
                positions[i*3+2] = (Math.random()-0.5)*160;
                vels.push({ y: Math.random()*0.07+0.02, x: (Math.random()-0.5)*0.03 });
            }
            snowGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            snowPoints = new THREE.Points(snowGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.15, transparent: true, opacity: 0.7 }));
            snowPoints.userData.vels = vels;
            scene.add(snowPoints);
        }

        function generatePhotoCloud(data) {
            photoCloud.forEach(p => scene.remove(p));
            photoCloud = [];
            data.forEach((item, i) => {
                const { tex, aspect } = item;
                const pHeight = 5.5;
                const pWidth = pHeight * aspect;
                const pGeo = new THREE.PlaneGeometry(pWidth, pHeight);
                const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide, transparent: true });
                const mesh = new THREE.Mesh(pGeo, mat);
                
                const angle = (i / data.length) * Math.PI * 6.5;
                const dist = (32 - (i / data.length) * 32) * 0.4 + 4;
                const y = (i / data.length) * 30 + 1;
                
                mesh.userData.treePos = new THREE.Vector3(Math.cos(angle)*dist, y, Math.sin(angle)*dist);
                mesh.userData.treeRot = new THREE.Euler(0, -angle + Math.PI/2, 0);
                mesh.userData.scatterPos = new THREE.Vector3((Math.random()-0.5)*115, Math.random()*70, (Math.random()-0.5)*115);
                mesh.userData.scatterRot = new THREE.Euler(Math.random()*4, Math.random()*4, Math.random()*4);
                mesh.userData.aspect = aspect;
                
                mesh.position.copy(mesh.userData.treePos);
                mesh.rotation.copy(mesh.userData.treeRot);
                scene.add(mesh);
                photoCloud.push(mesh);
            });
        }

        // --- 2. æ ¸å¿ƒçŠ¶æ€è¿‡æ¸¡ ---
        function transition(target) {
            if (currentState === target && target !== STATE.ZOOM) return;
            currentState = target;
            const duration = 1800;
            const ease = TWEEN.Easing.Cubic.InOut;

            if (target === STATE.SCATTER) {
                new TWEEN.Tween(camera.position).to({ z: 90, y: 30, x: 0 }, duration).easing(ease).start();
                photoFrame.visible = false;
            } else if (target === STATE.TREE) {
                new TWEEN.Tween(camera.position).to({ x: 0, y: 15, z: 60 }, duration).easing(ease).start();
                photoFrame.visible = false;
            }

            [instancedSpheres, instancedCubes].forEach(mesh => {
                mesh.userData.coords.forEach((data, i) => {
                    const startPos = new THREE.Vector3();
                    mesh.getMatrixAt(i, dummy.matrix);
                    startPos.setFromMatrixPosition(dummy.matrix);
                    const endPos = (target === STATE.TREE) ? data.tree : data.scatter;
                    new TWEEN.Tween(startPos).to({ x: endPos.x, y: endPos.y, z: endPos.z }, duration).easing(ease).onUpdate(() => {
                        dummy.position.copy(startPos); dummy.updateMatrix();
                        mesh.setMatrixAt(i, dummy.matrix); mesh.instanceMatrix.needsUpdate = true;
                    }).start();
                });
            });

            photoCloud.forEach((mesh) => {
                let p, r, s = new THREE.Vector3(1, 1, 1);
                if (target === STATE.TREE) { p = mesh.userData.treePos; r = mesh.userData.treeRot; }
                else if (target === STATE.SCATTER) { p = mesh.userData.scatterPos; r = mesh.userData.scatterRot; }
                else if (target === STATE.ZOOM) {
                    if (mesh === window.selectedPhoto) {
                        const camDir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                        const zoomDist = 9.5; 
                        const worldPos = camera.position.clone().add(camDir.multiplyScalar(zoomDist));
                        const inverseSceneMatrix = new THREE.Matrix4().extractRotation(scene.matrixWorld).invert();
                        p = worldPos.applyMatrix4(inverseSceneMatrix);
                        
                        // å§¿æ€å¼ºåˆ¶å¯¹é½ç›¸æœºï¼šæ­£å‘å‘ˆç°
                        const camRot = camera.quaternion.clone();
                        const sceneRotInv = scene.quaternion.clone().invert();
                        r = new THREE.Euler().setFromQuaternion(sceneRotInv.multiply(camRot));
                        
                        photoFrame.visible = true;
                        new TWEEN.Tween(photoFrame.position).to({ x: p.x, y: p.y, z: p.z }, duration).easing(ease).start();
                        new TWEEN.Tween(photoFrame.rotation).to({ x: r.x, y: r.y, z: r.z }, duration).easing(ease).start();
                    } else { p = mesh.userData.scatterPos; r = mesh.userData.scatterRot; }
                }
                new TWEEN.Tween(mesh.position).to({ x: p.x, y: p.y, z: p.z }, duration).easing(ease).start();
                new TWEEN.Tween(mesh.rotation).to({ x: r.x, y: r.y, z: r.z }, duration).easing(ease).start();
                new TWEEN.Tween(mesh.scale).to({ x: s.x, y: s.y, z: s.z }, duration).easing(ease).start();
            });
        }

        // --- 3. èµ„æºæ•è·é€»è¾‘ ---
        const startBtn = document.getElementById('start-btn');
        const cameraBtn = document.getElementById('camera-btn');
        const uploadBtn = document.getElementById('upload-btn');
        const fileInput = document.getElementById('file-input');
        const audioInput = document.getElementById('audio-input');
        const statusMsg = document.getElementById('status-msg');
        const videoFeedback = document.getElementById('video-feedback');

        cameraBtn.onclick = async () => {
            cameraBtn.innerText = "è¯·æ±‚æˆæƒä¸­...";
            try {
                const cameraUtils = new window.Camera(videoFeedback, {
                    onFrame: async () => { if(handsReady) await hands.send({ image: videoFeedback }); },
                    width: 640, height: 480
                });
                await cameraUtils.start();
                videoFeedback.style.opacity = 0.8;
                cameraBtn.innerText = "âœ… è§†è§‰å·²å°±ç»ª";
                cameraBtn.classList.add('btn-disabled');
                uploadBtn.classList.remove('btn-disabled');
                initAI();
            } catch (err) {
                cameraBtn.innerText = "âŒ æ‘„åƒå¤´å¼€å¯å¤±è´¥";
            }
        };

        uploadBtn.onclick = () => {
            // æä¾›åŒé€‰é€»è¾‘
            const msg = "è¯·ä¸Šä¼ ç…§ç‰‡ã€‚å¦‚æœä½ ä¹‹å‰çš„ ezyZip.mp3 æœªå“ï¼Œä¹Ÿå¯ä»¥åœ¨æ­¤é‡æ–°é€‰æ‹©éŸ³é¢‘æ–‡ä»¶ã€‚";
            statusMsg.innerText = msg;
            fileInput.click();
        };

        fileInput.onchange = (e) => {
            const files = Array.from(e.target.files);
            const loader = new THREE.TextureLoader();
            photoData = [];
            let photoCount = 0;

            files.forEach(file => {
                if (file.type.startsWith('audio/')) {
                    audio.src = URL.createObjectURL(file);
                    audio.load();
                } else if (file.type.startsWith('image/')) {
                    const img = new Image();
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        img.src = ev.target.result;
                        img.onload = () => {
                            const tex = loader.load(ev.target.result);
                            tex.colorSpace = THREE.SRGBColorSpace;
                            photoData.push({ tex, aspect: img.width / img.height });
                            photoCount++;
                            if(photoCount > 0) {
                                generatePhotoCloud(photoData);
                                uploadBtn.innerText = `âœ… å·²è½½å…¥ ${photoCount} å¼ ç…§ç‰‡`;
                                startBtn.style.display = 'inline-block';
                                checkReady();
                            }
                        };
                    };
                    reader.readAsDataURL(file);
                }
            });
        };

        startBtn.onclick = () => {
            // æœ€ç»ˆå°è¯•æ’­æ”¾éŸ³é¢‘
            audio.play().then(() => {
                statusMsg.innerText = "ğŸ¶ éŸ³ä¹å·²åŒæ­¥";
            }).catch(e => {
                statusMsg.innerText = "âš ï¸ æµè§ˆå™¨æ‹¦æˆªï¼Œè¯·ç‚¹å‡»æŒ‰é’®é‡è¯•";
            });
            document.getElementById('overlay').style.opacity = 0;
            document.getElementById('hint-bar').style.display = 'flex';
            setTimeout(() => document.getElementById('overlay').remove(), 1000);
        };

        let handsReady = false;
        let hands;
        function initAI() {
            hands = new window.Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
            hands.onResults((res) => {
                if (!res.multiHandLandmarks || res.multiHandLandmarks.length === 0) return;
                const lm = res.multiHandLandmarks[0];
                const d = (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y);
                const isFist = [8, 12, 16, 20].every(i => d(lm[i], lm[0]) < 0.22);
                const isOpen = [8, 12, 16, 20].every(i => d(lm[i], lm[0]) > 0.45);
                const isPinch = d(lm[8], lm[4]) < 0.05;

                if (isFist) transition(STATE.TREE);
                else if (isPinch) {
                    if (currentState !== STATE.ZOOM) {
                        let bestDist = Infinity;
                        let selected = null;
                        photoCloud.forEach(photo => {
                            const wp = new THREE.Vector3();
                            photo.getWorldPosition(wp);
                            const sp = wp.clone().project(camera);
                            const cp = wp.clone().applyMatrix4(camera.matrixWorldInverse);
                            const score = Math.hypot(sp.x, sp.y) + (Math.abs(cp.z) * 0.05);
                            if (score < bestDist) { bestDist = score; selected = photo; }
                        });
                        window.selectedPhoto = selected;
                        transition(STATE.ZOOM);
                    }
                } else if (isOpen) transition(STATE.SCATTER);

                if (currentState === STATE.SCATTER) {
                    targetRotation.y = (lm[9].x - 0.5) * Math.PI * 1.5;
                    targetRotation.x = (lm[9].y - 0.5) * Math.PI * 0.8;
                }
            });
            hands.initialize().then(() => { handsReady = true; checkReady(); });
        }

        function checkReady() {
            if (photoData.length > 0 && handsReady) {
                startBtn.classList.remove('btn-disabled');
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();

            if (photoFrame && photoFrame.visible && window.selectedPhoto) {
                updateFrameParticles(5.5 * window.selectedPhoto.userData.aspect, 5.5);
            }

            if (snowPoints) {
                const pos = snowPoints.geometry.attributes.position.array;
                const vels = snowPoints.userData.vels;
                for (let i = 0; i < vels.length; i++) {
                    pos[i*3+1] -= vels[i].y;
                    pos[i*3] += vels[i].x + Math.sin(Date.now()*0.001+i)*0.01;
                    if (pos[i*3+1] < -10) { pos[i*3+1] = 100; pos[i*3] = (Math.random()-0.5)*160; }
                }
                snowPoints.geometry.attributes.position.needsUpdate = true;
            }

            if (currentState === STATE.TREE) { scene.rotation.y += 0.005; scene.rotation.x *= 0.95; }
            else {
                currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;
                currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
                scene.rotation.y = currentRotation.y; scene.rotation.x = currentRotation.x;
            }
            if(composer) composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if(composer) composer.setSize(window.innerWidth, window.innerHeight);
        });

        initScene();
        animate();
    </script>
</body>
</html>